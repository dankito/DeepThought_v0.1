package net.deepthought.android.db;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Environment;
import android.util.Log;

import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;
import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.dao.RuntimeExceptionDao;
import com.j256.ormlite.dao.cda.EntitiesCollection;
import com.j256.ormlite.dao.cda.EntitiesCollectionListener;
import com.j256.ormlite.instances.Instances;
import com.j256.ormlite.instances.RelationFieldTypeCreator;
import com.j256.ormlite.misc.TableInfoRegistry;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.table.TableUtils;

import net.deepthought.DataManager;
import net.deepthought.model.AppSettings;
import net.deepthought.model.Category;
import net.deepthought.model.DeepThought;
import net.deepthought.model.Device;
import net.deepthought.model.Entry;
import net.deepthought.model.EntryFragment;
import net.deepthought.model.EntryTemplate;
import net.deepthought.model.Group;
import net.deepthought.model.Keyword;
import net.deepthought.model.Periodical;
import net.deepthought.model.Person;
import net.deepthought.model.Tag;
import net.deepthought.model.User;
import net.deepthought.model.listener.CategoriesChangedListener;
import net.deepthought.model.listener.DeepThoughtListener;
import net.deepthought.model.listener.EntryFragmentsChangedListener;
import net.deepthought.model.listener.KeywordsChangedListener;
import net.deepthought.model.listener.TagsChangedListener;
import net.deepthought.persistence.db.BaseEntity;
import net.deepthought.persistence.db.IDataBaseDeepThoughtPersistenceManager;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Created by ganymed on 11/10/14.
 */
public class OrmLiteAndroidDeepThoughtPersistenceManagerBAK extends OrmLiteSqliteOpenHelper implements IDataBaseDeepThoughtPersistenceManager {

  private final static Logger log = LoggerFactory.getLogger(OrmLiteAndroidDeepThoughtPersistenceManagerBAK.class);

  protected final static String DatabaseBackupDatabaseNameSuffix = "_bak";
  protected final static int MaxDatabaseBackupsToKeep = 3;

  protected final static String DbUpgradeBackupTablePrefix = "bak_";


  // name of the database file for your application -- change to something appropriate for your app
  private static final String DATABASE_NAME = "DeepThought.db";
  // any time you make changes to your database objects, you may have to increase the database version
  private static final int DATABASE_VERSION = 13;

  // the DAO object we use to access the DeepThought table
  protected Dao<AppSettings, Long> appSettingsDao = null;
  protected Dao<Person, Long> personDao = null;
  protected Dao<User, Long> userDao = null;
  protected Dao<DeepThought, Long> deepThoughtDao = null;
  protected RuntimeExceptionDao<DeepThought, Long> deepThoughtRuntimeDao = null;

  protected Dao<Group, Long> groupDao = null;
  protected Dao<Device, Long> deviceDao = null;

  protected Dao<Category, Long> categoryDao = null;
  protected Dao<EntryFragment, Long> entryFragmentDao = null;
  protected Dao<Entry, Long> entryDao = null;
  protected Dao<EntryTemplate, Long> entryTemplateDao = null;
  protected Dao<Tag, Long> tagDao = null;
  protected Dao<Keyword, Long> keywordDao = null;

  protected Dao<File, Long> fileDao = null;
  protected Dao<Periodical, Long> periodicalDao = null;

  protected DeepThought currentDeepThought = null;

  protected int persistUpdatedEntitiesAfterMilliseconds = 10 * 1000; // persist changes after 10 seconds
  protected List<BaseEntity> unpersistedUpdatedEntities = new CopyOnWriteArrayList<>();
  protected Timer persistUpdatedEntitiesTimer = null;


  public OrmLiteAndroidDeepThoughtPersistenceManagerBAK(Context context) throws SQLException {
    super(context, getDatabasePath(DATABASE_NAME), null, DATABASE_VERSION/*, R.raw.ormlite_config*/);

    Instances.setFieldTypeCreator(new RelationFieldTypeCreator());
    TableInfoRegistry.getInstance().createTableInfos(connectionSource, new Class[] { DeepThought.class, Category.class, Tag.class, Entry.class } );
  }

  /**
   * This is called when the database is first created. Usually you should call createTable statements here to create
   * the tables that will store your data.
   */
  @Override
  public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {
    try {
      Log.i(OrmLiteAndroidDeepThoughtPersistenceManagerBAK.class.getName(), "onCreate");

      createAllTables(connectionSource);
    } catch (SQLException e) {
      Log.e(OrmLiteAndroidDeepThoughtPersistenceManagerBAK.class.getName(), "Can't create database", e);
      throw new RuntimeException(e);
    }
//// here we try inserting data in the on-create as a test
//    RuntimeExceptionDao<Entry, Long> dao = getSimpleDataDao();
//// create some deepThought in the onCreate
//    Entry testEntry = new Entry("Test Entry", "Lorem ipsum");
////    DeepThought deepThought = new DeepThought();
////    deepThought.addAsAuthorOnEntryFragment(testEntry);
////    dao.create(deepThought);
//    dao.create(testEntry);
//    Log.i(OrmLiteDeepThoughtPersistenceManager.class.getName(), "created new deepThought in onCreate");
  }

  /**
   * This is called when your application is upgraded and it has a higher version number. This allows you to adjust
   * the various data to match the new version number.
   */
  @Override
  public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {
    // TODO: check which tables from oldVersion to newVersion really changed and only upgrade that ones
    try {
      Log.i(OrmLiteAndroidDeepThoughtPersistenceManagerBAK.class.getName(), "onUpgrade");

      List<String> tableNames = new ArrayList<String>() {{ add("deep_thought"); add("categories"); add("entry"); add("tag"); }};
      Map<String, List<String>> tablesColumnNames = backupTables(db, tableNames);

      dropAllTables(connectionSource);

// after we drop the old databases, we create the new ones
      onCreate(db, connectionSource);
      copyDataFromBackupTablesAndDropBackups(db, tablesColumnNames);
    } catch (SQLException e) {
      Log.e(OrmLiteAndroidDeepThoughtPersistenceManagerBAK.class.getName(), "Can't drop databases", e);
      throw new RuntimeException(e);
    }
  }

  protected void createAllTables(ConnectionSource connectionSource) throws SQLException {
    TableUtils.createTable(connectionSource, DeepThought.class);
    TableUtils.createTable(connectionSource, Category.class);
    TableUtils.createTable(connectionSource, Entry.class);
    TableUtils.createTable(connectionSource, Tag.class);
  }

  protected void dropAllTables(ConnectionSource connectionSource) throws SQLException {
    try { TableUtils.dropTable(connectionSource, DeepThought.class, true); } catch(Exception ex) { log.error("Could not drop table for class " + DeepThought.class, ex); }
    try { TableUtils.dropTable(connectionSource, Category.class, true); } catch(Exception ex) { log.error("Could not drop table for class " + Category.class, ex); }
    try { TableUtils.dropTable(connectionSource, Entry.class, true); } catch(Exception ex) { log.error("Could not drop table for class " + Entry.class, ex); }
    try { TableUtils.dropTable(connectionSource, Tag.class, true); } catch(Exception ex) { log.error("Could not drop table for class " + Tag.class, ex); }
  }

  protected Map<String, List<String>> backupTables(SQLiteDatabase db, List<String> tableNames) {
    Map<String, List<String>> tablesColumnNames = new HashMap<>();

    for(String tableName : tableNames) {
      try {
        List<String> tableColumnNames = backupTable(db, tableName);
        tablesColumnNames.put(tableName, tableColumnNames); }
      catch(Exception ex) { log.error("Could not backup table " + tableName, ex); }
    }

    return tablesColumnNames;
  }

  protected List<String> backupTable(SQLiteDatabase db, String tableName) {
    List<String> columns = GetColumns(db, tableName);

    String backupDatabaseStatement = "ALTER table " + tableName + " RENAME TO '" + DbUpgradeBackupTablePrefix + tableName + "'";
    db.execSQL(backupDatabaseStatement);

    return columns;
  }

  protected void copyDataFromBackupTablesAndDropBackups(SQLiteDatabase db, Map<String, List<String>> previousTablesColumnNames) {
    for(String tableName : previousTablesColumnNames.keySet()) {
      try {
        copyDataFromBackupTableAndDrop(db, previousTablesColumnNames, tableName);
      } catch(Exception ex) { log.error("Could not copy data from backup table " + tableName, ex); }
    }
  }

  protected void copyDataFromBackupTableAndDrop(SQLiteDatabase db, Map<String, List<String>> previousTablesColumnNames, String tableName) {
    List<String> tablePreviousColumns = previousTablesColumnNames.get(tableName);
    tablePreviousColumns.retainAll(GetColumns(db, tableName)); // intersect previous and new column names

    String columnsString = join(tablePreviousColumns, ",");
    db.execSQL(String.format( "INSERT INTO %s (%s) SELECT %s from " + DbUpgradeBackupTablePrefix + "%s", tableName, columnsString, columnsString, tableName));

    db.execSQL("DROP table " + DbUpgradeBackupTablePrefix + tableName);
  }

  public static List<String> GetColumns(SQLiteDatabase db, String tableName) {
    List<String> ar = null;
    Cursor c = null;
    try {
      c = db.rawQuery("select * from " + tableName + " limit 1", null);
      if (c != null) {
        ar = new ArrayList<String>(Arrays.asList(c.getColumnNames()));
      }
    } catch (Exception e) {
      Log.v(tableName, e.getMessage(), e);
      e.printStackTrace();
    } finally {
      if (c != null)
        c.close();
    }
    return ar;
  }

  public static String join(List<String> list, String delim) {
    StringBuilder buf = new StringBuilder();
    int num = list.size();
    for (int i = 0; i < num; i++) {
      if (i != 0)
        buf.append(delim);
      buf.append((String) list.get(i));
    }
    return buf.toString();
  }

//  @Override
//  public <D extends Dao<T, ?>, T> D getDao(Class<T> clazz) throws SQLException {
//    Dao<T, ?> dao = super.getDao(clazz);
//    return dao;
//  }

  public Dao<AppSettings, Long> getAppSettingsDao() throws SQLException {
    if (appSettingsDao == null) {
      createAllDaos();
    }

    return appSettingsDao;
  }

  /**
   * Returns the Database Access Object (DAO) for our DeepThought class. It will create it or just give the cached
   * value.
   */
  public Dao<DeepThought, Long> getDeepThoughtDao() throws SQLException {
    if (deepThoughtDao == null) {
      createAllDaos();
    }

    return deepThoughtDao;
  }

  protected void createAllDaos() throws SQLException {
    appSettingsDao = getDao(AppSettings.class);
    appSettingsDao.setObjectCache(true);
    appSettingsDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    personDao = getDao(Person.class);
    personDao.setObjectCache(true);
    personDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    userDao = getDao(User.class);
    userDao.setObjectCache(true);
    userDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    groupDao = getDao(Group.class);
    groupDao.setObjectCache(true);
    groupDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    deviceDao = getDao(Device.class);
    deviceDao.setObjectCache(true);
    deviceDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    deepThoughtDao = getDao(DeepThought.class);
    deepThoughtDao.setObjectCache(true);
    //deepThoughtDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    categoryDao = getDao(Category.class);
    categoryDao.setObjectCache(true);
    categoryDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    entryFragmentDao = getDao(EntryFragment.class);
    entryFragmentDao.setObjectCache(true);
    entryFragmentDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    entryDao = getDao(Entry.class);
    entryDao.setObjectCache(true);
    entryDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    entryTemplateDao = getDao(EntryTemplate.class);
    entryTemplateDao.setObjectCache(true);
    entryTemplateDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    tagDao = getDao(Tag.class);
    tagDao.setObjectCache(true);
    tagDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    keywordDao = getDao(Keyword.class);
    keywordDao.setObjectCache(true);
    keywordDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    fileDao = getDao(File.class);
    fileDao.setObjectCache(true);
    fileDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?

    periodicalDao = getDao(Periodical.class);
    periodicalDao.setObjectCache(true);
    periodicalDao.setAutoCommit(getConnectionSource().getReadWriteConnection(), true); // TODO: is this of any use (does it do anything)?
  }

  /**
   * Returns the RuntimeExceptionDao (Database Access Object) version of a Dao for our DeepThought class. It will
   * create it or just give the cached value. RuntimeExceptionDao only through RuntimeExceptions.
   */
  public RuntimeExceptionDao<DeepThought, Long> getSimpleDataDao() {
    if (deepThoughtRuntimeDao == null) {
      deepThoughtRuntimeDao = getRuntimeExceptionDao(DeepThought.class);
    }
    return deepThoughtRuntimeDao;
  }

  public Dao<Category, Long> getCategoryDao() throws SQLException {
    if (categoryDao == null) {
      createAllDaos();
    }

    return categoryDao;
  }

  public Dao<Entry, Long> getEntryDao() throws SQLException {
    if (entryDao == null) {
      createAllDaos();
    }

    return entryDao;
  }

  public Dao<Tag, Long> getTagDao() throws SQLException {
    if (tagDao == null) {
      createAllDaos();
    }

    return tagDao;
  }


  public void clearData() {
    try {
      dropAllTables(getConnectionSource());
      createAllTables(getConnectionSource());
    } catch (SQLException ex) {
      log.error("Could not clear data (drop all tables)", ex);
    }
  }

  @Override
  public <T> List<T> doNativeQuery(String query) {
    SQLiteDatabase readableDatabase = getReadableDatabase();
    Cursor cursor = readableDatabase.rawQuery(query, new String[0]);

    List rows = new ArrayList<String[]>();

    while(cursor.moveToNext()) {
      String[] row = new String[cursor.getColumnCount()];
      for(int i = 0; i < row.length; i++)
        row[i] = cursor.getString(i);
      rows.add(row);
    }

//    readableDatabase.close();

    return rows;
  }

  @Override
  public int doNativeExecute(String statement) {
    return 0;
  }

  /**
   * Close the database connections and clear any cached DAOs.
   */
  @Override
  public void close() {
    super.close();
    deepThoughtDao = null;
    deepThoughtRuntimeDao = null;
    categoryDao = null;
    entryDao = null;
    tagDao = null;
  }

  @Override
  public void deserializeDeepThoughtAsync(final DeserializeDeepThoughtResult result) {
    new Thread(new Runnable() {
      @Override
      public void run() {
        try {
          result.result(true, null, deserializeDeepThought());
        } catch(Exception ex) {
          result.result(false, ex, null);
        }
      }
    });
  }

  @Override
  public DeepThought deserializeDeepThought() throws Exception {
    List<AppSettings> appSettingsQueryResult = getAppSettingsDao().queryForAll();
    if(appSettingsQueryResult.size() > 0) {
      if(appSettingsQueryResult.size() > 1)
        log.warn("There are more than one AppSettings persisted in Database, a total amount of " + appSettingsQueryResult.size());

      AppSettings appSettings = appSettingsQueryResult.get(0);
      User lastLoggedOnUser = appSettings.getLastLoggedOnUser();
      if(appSettings.autoLogOnLastLoggedOnUser()) {
        User.setCurrentlyLoggedOnUser(lastLoggedOnUser);

        DeepThought deepThought = lastLoggedOnUser.getLastViewedDeepThought();
        setCurrentDeepThought(deepThought);

        return deepThought;
      }
    }

    return createAndPersistDefaultDeepThought();
  }

  protected DeepThought createAndPersistDefaultDeepThought() throws Exception {
//    for(EntryTemplate systemEntryTemplate : SystemEntryTemplates.allSystemEntryTemplates())
//      addEntryTemplate(systemEntryTemplate);
//    EntryTemplateRegistry.setEntryTemplates(EntryTemplateRegistry.createSystemEntryTemplates());
//    for(EntryTemplate systemEntryTemplate : EntryTemplateRegistry.getAllEntryTemplates())
//      addEntryTemplate(systemEntryTemplate);

    User defaultLocalUser = User.createNewLocalUser();
    persistEntity(defaultLocalUser);

    AppSettings appSettings = new AppSettings(DataManager.CurrentDataModelVersion, defaultLocalUser, true);
    persistEntity(appSettings);

    DeepThought newDeepThought = new ArrayList<>(defaultLocalUser.getDeepThoughts()).get(0);
    setCurrentDeepThought(newDeepThought);

    return newDeepThought;
  }

  protected void persistEntity(BaseEntity entity) {

  }

  protected void setCurrentDeepThought(DeepThought deepThought) {
    if(currentDeepThought != null)
      removeDeepThoughtListeners(currentDeepThought);

    currentDeepThought = deepThought;

    setDeepThoughtListeners(currentDeepThought);
  }

  protected void setDeepThoughtListeners(DeepThought deepThought) {
    deepThought.addDeepThoughtListener(deepThoughtListener);
    deepThought.addCategoriesChangedListener(categoriesChangedListener);
    deepThought.addEntriesChangedListener(entryFragmentsChangedListener);
    deepThought.addTagsChangedListener(tagsChangedListener);
    deepThought.addKeywordsChangedListener(keywordsChangedListener);

    if(deepThought.getCategories() instanceof EntitiesCollection) {
      ((EntitiesCollection) deepThought.getCategories()).addEntitiesCollectionListener(entitiesCollectionListener);
    }
    else
      log.warn("deepThought.getEntryFragments() is of instance " + deepThought.getEntries().getClass() + ", not of EntitiesCollection");

    if(deepThought.getEntries() instanceof EntitiesCollection) {
      ((EntitiesCollection) deepThought.getEntries()).addEntitiesCollectionListener(entitiesCollectionListener);
    }
    else
      log.warn("deepThought.getEntryFragments() is of instance " + deepThought.getEntries().getClass() + ", not of EntitiesCollection");

    if(deepThought.getTags() instanceof EntitiesCollection) {
      ((EntitiesCollection) deepThought.getTags()).addEntitiesCollectionListener(entitiesCollectionListener);
    }
    else
      log.warn("deepThought.getTags() is of instance " + deepThought.getTags().getClass() + ", not of EntitiesCollection");

    if(deepThought.getKeywords() instanceof EntitiesCollection) {
      ((EntitiesCollection) deepThought.getKeywords()).addEntitiesCollectionListener(entitiesCollectionListener);
    }
    else
      log.warn("deepThought.getKeywords() is of instance " + deepThought.getKeywords().getClass() + ", not of EntitiesCollection");
  }

  protected void removeDeepThoughtListeners(DeepThought deepThought) {
    deepThought.removeDeepThoughtListener(deepThoughtListener);
    deepThought.removeCategoriesChangedListener(categoriesChangedListener);
    deepThought.removeEntriesChangedListener(entryFragmentsChangedListener);
    deepThought.removeTagsChangedListener(tagsChangedListener);
    deepThought.removeKeywordsChangedListener(keywordsChangedListener);

    if(deepThought.getEntries() instanceof EntitiesCollection) {
      ((EntitiesCollection) deepThought.getEntries()).removeEntitiesCollectionListener(entitiesCollectionListener);
    }
    else
      log.warn("deepThought.getEntryFragments() is of instance " + deepThought.getEntries().getClass() + ", not of EntitiesCollection");

    if(deepThought.getTags() instanceof EntitiesCollection) {
      ((EntitiesCollection) deepThought.getTags()).removeEntitiesCollectionListener(entitiesCollectionListener);
    }
    else
      log.warn("deepThought.getTags() is of instance " + deepThought.getTags().getClass() + ", not of EntitiesCollection");
  }

  @Override
  public boolean persistDeepThought(DeepThought deepThought) throws Exception {
    return getDeepThoughtDao().createOrUpdate(deepThought).getNumLinesChanged() == 1;
//    return false;
  }

//  @Override
//  public List<EntryTemplate> getAllEntryTemplates() {
//    return null;
//  }
//
//  @Override
//  public boolean addEntryTemplate(EntryTemplate entryTemplate) {
//    return false;
//  }


  public int getPersistUpdatedEntitiesAfterMilliseconds() {
    return persistUpdatedEntitiesAfterMilliseconds;
  }

  public void setPersistUpdatedEntitiesAfterMilliseconds(int persistUpdatedEntitiesAfterMilliseconds) {
    this.persistUpdatedEntitiesAfterMilliseconds = persistUpdatedEntitiesAfterMilliseconds;
  }

  protected synchronized void entityUpdated(BaseEntity entity) {
    if(persistUpdatedEntitiesAfterMilliseconds == 0) // persist modifiedOn entities immediately
      persistUpdatedEntity(entity);
    else {
      unpersistedUpdatedEntities.add(entity);

      if(persistUpdatedEntitiesTimer == null) { // if persistUpdatedEntitiesTimer != null it has already been set another entity
        createPersistUpdatedEntitiesTimer();
      }
    }
  }

  protected void createPersistUpdatedEntitiesTimer() {
    persistUpdatedEntitiesTimer = new Timer("Persist updated Entities timer");

    persistUpdatedEntitiesTimer.schedule(new TimerTask() {
      @Override
      public void run() {
        persistUpdatedEntitiesTimer = null;
        persistUpdatedEntities();
      }
    }, persistUpdatedEntitiesAfterMilliseconds);
  }

  protected void persistUpdatedEntities() {
    for(BaseEntity updatedEntity : unpersistedUpdatedEntities)
      persistUpdatedEntity(updatedEntity);

    unpersistedUpdatedEntities.clear();
  }

  protected void persistUpdatedEntity(BaseEntity entity) {
    try {
      if (entity instanceof Category)
        getCategoryDao().createOrUpdate((Category) entity);
      else if (entity instanceof Entry)
        getEntryDao().createOrUpdate((Entry) entity);
      else if(entity instanceof Tag)
        getTagDao().createOrUpdate((Tag)entity);
    } catch(Exception ex) { log.error("Could not persisted updated entity " + entity, ex); }
  }


  protected DeepThoughtListener deepThoughtListener = new DeepThoughtListener() {
    @Override
    public void propertyChanged(DeepThought entity, String propertyName, Object newValue, Object previewValue) {
      entityUpdated(entity);
    }
  };

  protected CategoriesChangedListener categoriesChangedListener = new CategoriesChangedListener() {
    @Override
    public void categoryAdded(Category category) {

    }

    @Override
    public void categoryUpdated(Category category) {
      entityUpdated(category);
    }

    @Override
    public void categoryRemoved(Category category) {

    }
  };

  protected EntryFragmentsChangedListener entryFragmentsChangedListener = new EntryFragmentsChangedListener() {

    @Override
    public void entryFragmentAdded(EntryFragment entryFragment) {

    }

    @Override
    public void entryFragmentUpdated(EntryFragment entryFragment) {
      entityUpdated(entryFragment);
    }

    @Override
    public void entryFragmentRemoved(EntryFragment entryFragment) {

    }
  };

  protected TagsChangedListener tagsChangedListener = new TagsChangedListener() {
    @Override
    public void tagAdded(Tag tag) {

    }

    @Override
    public void tagUpdated(Tag tag) {
      entityUpdated(tag);
    }

    @Override
    public void tagRemoved(Tag tag) {

    }
  };

  protected KeywordsChangedListener keywordsChangedListener = new KeywordsChangedListener() {
    @Override
    public void keywordAdded(Keyword keyword) {

    }

    @Override
    public void keywordUpdated(Keyword keyword) {
      entityUpdated(keyword);
    }

    @Override
    public void keywordRemoved(Keyword keyword) {

    }
  };


  protected EntitiesCollectionListener<BaseEntity> entitiesCollectionListener = new EntitiesCollectionListener<BaseEntity>() {
    @Override
    public void itemAdded(BaseEntity item) {

    }

    @Override
    public void entityMapped(BaseEntity entity) {
      currentDeepThought.lazyLoadedEntityMapped(entity);
    }

    @Override
    public void itemRemoved(BaseEntity item) {

    }

    @Override
    public void cacheCleared(List<BaseEntity> cachedEntities) {
      for(BaseEntity entity : cachedEntities)
        currentDeepThought.entityInstanceRemoved(entity);
    }
  };

  @Override
  public void onOpen(SQLiteDatabase db) {
    try {
      makeBackupOfDatabase(db);
    } catch(Exception ex) { log.error("Could not create a backup of database file " + db.getPath(), ex); }

    super.onOpen(db);
  }

  protected void makeBackupOfDatabase(SQLiteDatabase db) {
    String databasePath = db.getPath();

    File maxBackupFile = new File(databasePath + DatabaseBackupDatabaseNameSuffix + MaxDatabaseBackupsToKeep);
    if(maxBackupFile.exists())
      maxBackupFile.delete();

    for(int i = MaxDatabaseBackupsToKeep - 1; i > 0; i--) {
      File backupFile = new File(databasePath + DatabaseBackupDatabaseNameSuffix + i);
      if(backupFile.exists())
        backupFile.renameTo(new File(databasePath + DatabaseBackupDatabaseNameSuffix + (i + 1)));
    }

    File currentDatabaseFile = new File(databasePath);
    if(currentDatabaseFile.exists())
      copyFile(currentDatabaseFile, new File(databasePath + DatabaseBackupDatabaseNameSuffix + 1));

    tryToCopyToExternalStorage(db);
  }

  private void tryToCopyToExternalStorage(SQLiteDatabase db) {
    try {
      if(Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
        String filename = new File(db.getPath()).getName();
        DateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd_HH:mm:ss");
        filename = filename.replace(".db", "_" + dateFormat.format(new Date()) + ".db");

        File folder = Environment.getExternalStorageDirectory();
        folder = new File(folder, "DeepThought");
        if(folder.exists() == false)
          folder.mkdir();

        folder = new File(folder, "db_backups");
        if(folder.exists() == false)
          folder.mkdir();

        copyFile(new File(db.getPath()), new File(folder, filename));
      }
    } catch(Exception ex) { log.error("Could not copy a Database Backup to External Storage", ex); }
  }

  public void copyFile(File source, File destination) {
    try {
      InputStream inputStream = new FileInputStream(source);
      OutputStream outputStream = new FileOutputStream(destination);

      // Transfer bytes from inputStream to outputStream
      byte[] buf = new byte[10 * 1024];
      int len;
      while ((len = inputStream.read(buf)) > 0) {
        outputStream.write(buf, 0, len);
      }

      inputStream.close();
      outputStream.close();
    } catch(Exception ex) { log.error("Could not copy file " + source + " to " + destination, ex); }
  }

  private static String getDatabasePath(String databaseName) {
    return databaseName;
  }
}
